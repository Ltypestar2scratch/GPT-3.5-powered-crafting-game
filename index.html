<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Element Cloning and Dragging</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      align-items: center;
      height: 100vh;
      margin: 0;
      overflow: hidden;
      position: relative;
    }
    #sidebar {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 150px;
      background-color: #f0f0f0;
      padding: 10px;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-y: auto;
    }
    .element {
      padding: 10px;
      margin: 5px 0;
      font-size: 2rem;
      cursor: pointer;
      display: inline-block;
      width: 100%;
      text-align: center;
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .cloned {
      position: absolute;
      cursor: move;
      padding: 10px;
      margin: 0;
      font-size: 2rem;
      z-index: 1000;
    }
    #sound-button {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 10px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      cursor: pointer;
    }
    #counter {
      position: absolute;
      top: 10px;
      left: calc(50% - 75px);
      width: 150px;
      text-align: center;
      font-size: 1.5rem;
      background-color: #fff;
      border: 1px solid #ddd;
      padding: 5px;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
    }
    #discovery-counter {
      position: absolute;
      bottom: 10px;
      left: calc(50% - 150px);
      width: 300px;
      text-align: center;
      font-size: 1.5rem;
      background-color: #fff;
      border: 1px solid #ddd;
      padding: 5px;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
    }
    #win-message {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-size: 2rem;
      background-color: #fff;
      border: 1px solid #ddd;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.5);
    }
    #win-message small {
      display: block;
      margin-top: 10px;
      font-size: 1rem;
    }
  </style>
</head>
<body>

<div id="sidebar">
  <div class="element" data-type="Earth" data-label="Earth">üåç Earth</div>
  <div class="element" data-type="Wind" data-label="Wind">üí® Wind</div>
  <div class="element" data-type="Fire" data-label="Fire">üî• Fire</div>
  <div class="element" data-type="Water" data-label="Water">üíß Water</div>
</div>

<audio id="combination-sound" src="https://www.myinstants.com/media/sounds/infinite-craft-combination-sound.mp3"></audio>
<audio id="background-music" src="https://audio.jukehost.co.uk/wl0e25Z3hlm71SRocr2JRVTYWxsnRLuA" loop></audio>

<button id="sound-button">Turn Sound On</button>
<div id="counter">Total Elements: 4</div>
<div id="discovery-counter">How many elements you discovered: 4</div>

<div id="win-message">
  <p>You won! ü§ëü§ëü§ë</p>
  <small>Thanks for playing this short game üòäüòäüòä</small>
</div>

<script>
  let currentDraggedElement = null;
  let elementsToCheck = [];
  let soundEnabled = false; // Track sound state

  // Variable to specify the total number of elements, or "Don't know" to calculate dynamically
  const totalElementsVariable = "39";

  // UHHHHH
  const lookupTable = {
    'Fire+Fire': { emoji: 'üî•', name: 'Fire' },
    'Water+Fire': { emoji: 'üí®', name: 'Steam' },
    'Wind+Fire': { emoji: 'üå´Ô∏è', name: 'Smoke' },
    'Earth+Fire': { emoji: 'üåã', name: 'Magma' },
    'Water+Water': { emoji: 'üßä', name: 'Ice' },
    'Wind+Water': { emoji: 'üßä', name: 'Ice' },
    'Earth+Water': { emoji: 'ü™®', name: 'Mud' },
    'Wind+Wind': { emoji: 'üå¨Ô∏è', name: 'Air' },
    'Earth+Wind': { emoji: '‚õàÔ∏è', name: 'Storm' },
    'Earth+Earth': { emoji: 'üåßÔ∏è', name: 'Mud' },
    'Steam+Fire': { emoji: 'üíß', name: 'Water' },
    'Smoke+Fire': { emoji: 'üí®', name: 'Air' },
    'Magma+Fire': { emoji: 'üåã', name: 'Lava' },
    'Ice+Fire': { emoji: 'üí®', name: 'Steam' },
    'Mud+Fire': { emoji: 'üåã', name: 'Lava' },
    'Air+Fire': { emoji: '‚ö°', name: 'Lightning' },
    'Storm+Fire': { emoji: '‚ö°', name: 'Lightning' },
    'Steam+Water': { emoji: 'üü°', name: 'Hydrogen' },
    'Smoke+Water': { emoji: 'üí®', name: 'Steam' },
    'Magma+Water': { emoji: 'üí®', name: 'Steam' },
    'Ice+Water': { emoji: 'üßä', name: 'Iceberg' },
    'Mud+Water': { emoji: 'üß±', name: 'Clay' },
    'Air+Water': { emoji: '‚ùÑÔ∏è', name: 'Ice' },
    'Storm+Water': { emoji: 'üåßÔ∏è', name: 'Rain' },
    'Steam+Wind': { emoji: '‚ö°', name: 'Electricity' },
    'Smoke+Wind': { emoji: 'üí®', name: 'Air' },
    'Magma+Wind': { emoji: 'üåã', name: 'Volcano' },
    'Ice+Wind': { emoji: 'üíß', name: 'Water' },
    'Mud+Wind': { emoji: 'üèñÔ∏è', name: 'Sand' },
    'Air+Wind': { emoji: 'üí®', name: 'Oxygen' },
    'Storm+Wind': { emoji: 'üí®', name: 'Oxygen' },
    'Steam+Earth': { emoji: 'üü§', name: 'Mud' },
    'Smoke+Earth': { emoji: 'üî•', name: 'Ash' },
    'Magma+Earth': { emoji: 'ü™®', name: 'Basalt' },
    'Ice+Earth': { emoji: 'üí©', name: 'Mud' },
    'Mud+Earth': { emoji: 'ü™®', name: 'Clay' },
    'Air+Earth': { emoji: 'üå´Ô∏è', name: 'Dust' },
    'Storm+Earth': { emoji: 'ü™®', name: 'Mud' },
    'Steam+Steam': { emoji: 'üíß', name: 'Water' },
    'Smoke+Steam': { emoji: 'üå´Ô∏è', name: 'Fog' },
    'Magma+Steam': { emoji: 'üíß', name: 'Water' },
    'Ice+Steam': { emoji: 'üíß', name: 'Water' },
    'Mud+Steam': { emoji: 'üíß', name: 'Water' },
    'Air+Steam': { emoji: 'üíß', name: 'Water' },
    'Storm+Steam': { emoji: 'üåßÔ∏è', name: 'Rain' },
    'Smoke+Smoke': { emoji: 'üî•', name: 'Fire' },
    'Magma+Smoke': { emoji: 'üåã', name: 'Volcano' },
    'Ice+Smoke': { emoji: 'üíß', name: 'Water' },
    'Mud+Smoke': { emoji: 'üß±', name: 'Clay' },
    'Air+Smoke': { emoji: 'ü™®', name: 'Carbon' },
    'Storm+Smoke': { emoji: 'üí®', name: 'Oxygen' },
    'Magma+Magma': { emoji: 'üî•', name: 'Lava' },
    'Ice+Magma': { emoji: 'ü™®', name: 'Basalt' },
    'Mud+Magma': { emoji: 'ü™®', name: 'Clay' },
    'Air+Magma': { emoji: 'üåã', name: 'Lava' },
    'Storm+Magma': { emoji: '‚ö°Ô∏è', name: 'Lightning' },
    'Ice+Ice': { emoji: 'üíß', name: 'Water' },
    'Mud+Ice': { emoji: 'ü•§', name: 'Slush' },
    'Air+Ice': { emoji: 'üíß', name: 'Water' },
    'Storm+Ice': { emoji: '‚ùÑÔ∏è', name: 'Snow' },
    'Mud+Mud': { emoji: 'üß±', name: 'Clay' },
    'Air+Mud': { emoji: 'ü™®', name: 'Clay' },
    'Storm+Mud': { emoji: 'ü™®', name: 'Clay' },
    'Air+Air': { emoji: 'üå¨Ô∏è', name: 'Wind' },
    'Storm+Air': { emoji: '‚ö°', name: 'Lightning' },
    'Storm+Storm': { emoji: 'üåÄ', name: 'Hurricane' },
    'Lava+Fire': { emoji: 'üåã', name: 'Magma' },
    'Lightning+Fire': { emoji: '‚ö°Ô∏èüî•', name: 'Plasma' },
    'Hydrogen+Fire': { emoji: 'H‚ÇÇ', name: 'Hydrogen' },
    'Iceberg+Fire': { emoji: 'üíß', name: 'Water' },
    'Clay+Fire': { emoji: 'üè∫', name: 'Ceramic' },
    'Rain+Fire': { emoji: 'üí®', name: 'Steam' },
    'Electricity+Fire': { emoji: '‚ö°Ô∏èüî•', name: 'Plasma' },
    'Volcano+Fire': { emoji: 'üåã', name: 'Magma' },
    'Sand+Fire': { emoji: 'ü•Ç', name: 'Glass' },
    'Oxygen+Fire': { emoji: 'üåå', name: 'Ozone' },
    'Ash+Fire': { emoji: 'üß™', name: 'Phosphorus' },
    'Basalt+Fire': { emoji: 'üåã', name: 'Lava' },
    'Dust+Fire': { emoji: 'ü™µ', name: 'Ash' },
    'Fog+Fire': { emoji: 'üí®', name: 'Smoke' },
    'Carbon+Fire': { emoji: 'üå´Ô∏è', name: 'Carbon dioxide' },
    'Slush+Fire': { emoji: 'üíß', name: 'Water' },
    'Snow+Fire': { emoji: 'üí®', name: 'Steam' },
    'Hurricane+Fire': { emoji: '‚ö°Ô∏è', name: 'Plasma' },
    'Lava+Water': { emoji: 'üí®', name: 'Steam' },
    'Lightning+Water': { emoji: '‚ö°', name: 'Electricity' },
    'Hydrogen+Water': { emoji: 'üíß', name: 'H‚ÇÇO' },
    'Iceberg+Water': { emoji: 'üßä', name: 'Ice' },
    'Clay+Water': { emoji: 'üí©', name: 'Mud' },
    'Rain+Water': { emoji: 'üíß', name: 'Hydrogen' },
    'Electricity+Water': { emoji: 'üíß', name: 'Hydrogen' },
    'Volcano+Water': { emoji: 'üí®', name: 'Steam' },
    'Sand+Water': { emoji: 'üåßÔ∏è', name: 'Mud' },
    'Oxygen+Water': { emoji: 'üíß', name: 'Hydrogen' },
    'Ash+Water': { emoji: 'üß™', name: 'Lye' },
    'Basalt+Water': { emoji: 'üü§', name: 'Mud' },
    'Dust+Water': { emoji: 'ü™®', name: 'Mud' },
    'Fog+Water': { emoji: 'üå´Ô∏è', name: 'Mist' },
    'Carbon+Water': { emoji: 'üç≠', name: 'Glucose' },
    'Slush+Water': { emoji: 'üßä', name: 'Ice' },
    'Snow+Water': { emoji: 'üßä', name: 'Ice' },
    'Hurricane+Water': { emoji: 'üåßÔ∏è', name: 'Rain' },
    'Lava+Wind': { emoji: 'üåã', name: 'Ash' },
    'Lightning+Wind': { emoji: 'üå¨Ô∏è', name: 'Air' }
  };

  // Function to calculate total elements if the variable is "Don't know"
  function calculateTotalElements() {
    const numStartingElements = 4; // Initial number of elements
    const numLookupElements = Object.keys(lookupTable).length;
    return numStartingElements + numLookupElements;
  }

  // Function to update the counters
  function updateCounters() {
    let totalElements;

    // Check if we have a specific total elements count
    if (totalElementsVariable === "Don't know") {
      totalElements = calculateTotalElements();
    } else {
      totalElements = totalElementsVariable;
    }

    const discoveredElements = document.querySelectorAll('#sidebar .element').length;

    // Update top counter
    document.getElementById('counter').textContent = `Total Elements: ${totalElements}`;

    // Update bottom counter
    const discoveryCounter = document.getElementById('discovery-counter');
    if (discoveredElements >= totalElements / 2) {
      discoveryCounter.textContent = `How many elements are left to discover out there: ${totalElements - discoveredElements}`;
    } else {
      discoveryCounter.textContent = `How many elements you discovered: ${discoveredElements}`;
    }

    // Show win message if all elements are discovered
    if (discoveredElements === totalElements) {
      document.getElementById('win-message').style.display = 'block';
    }
  }

  // Call updateCounters initially
  updateCounters();

  // Add event listener to all element divs
  document.querySelectorAll('.element').forEach(el => {
    el.addEventListener('click', function() {
      cloneElement(el);
    });
  });

  // Sound button functionality
  const soundButton = document.getElementById('sound-button');
  soundButton.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    if (soundEnabled) {
      soundButton.textContent = 'Turn Sound Off';
      document.getElementById('background-music').play();
    } else {
      soundButton.textContent = 'Turn Sound On';
      document.getElementById('background-music').pause();
    }
  });

  // Function to clone elements
  function cloneElement(originalElement) {
    const clonedElement = originalElement.cloneNode(true);
    clonedElement.classList.add('cloned');
    clonedElement.dataset.label = originalElement.dataset.label;
    clonedElement.style.width = `${originalElement.offsetWidth}px`;
    clonedElement.style.height = `${originalElement.offsetHeight}px`;
    clonedElement.style.position = 'absolute';
    clonedElement.style.left = '50px'; // Initial position
    clonedElement.style.top = '50px'; // Initial position

    clonedElement.addEventListener('mousedown', function(event) {
      currentDraggedElement = clonedElement;
      clonedElement.style.zIndex = '1001'; // Bring to front when dragging
      moveElement(event);
    });

    clonedElement.addEventListener('mouseup', function() {
      if (currentDraggedElement) {
        elementsToCheck.push(clonedElement);
        clonedElement.style.zIndex = '1000'; // Reset z-index after dragging
      }
    });

    document.addEventListener('mousemove', moveElement);
    document.addEventListener('mouseup', handleMouseUp);

    document.body.appendChild(clonedElement);
    updateCounters(); // Update counter when a new element is added
  }

  function moveElement(event) {
    if (currentDraggedElement) {
      const x = event.clientX - (currentDraggedElement.offsetWidth / 2);
      const y = event.clientY - (currentDraggedElement.offsetHeight / 2);
      currentDraggedElement.style.left = x + 'px';
      currentDraggedElement.style.top = y + 'px';
    }
  }

  function handleMouseUp() {
    if (currentDraggedElement) {
      const sidebarRect = document.getElementById('sidebar').getBoundingClientRect();
      const currentDraggedRect = currentDraggedElement.getBoundingClientRect();
      
      if (currentDraggedRect.right > sidebarRect.left &&
          currentDraggedRect.left < sidebarRect.right &&
          currentDraggedRect.bottom > sidebarRect.top &&
          currentDraggedRect.top < sidebarRect.bottom) {
        // If the cloned element is inside the sidebar, delete it
        document.body.removeChild(currentDraggedElement);
      } else {
        // Check for collisions with other cloned elements
        const clonedElements = document.querySelectorAll('.cloned');
        clonedElements.forEach(el => {
          if (el !== currentDraggedElement && isColliding(currentDraggedElement, el)) {
            const combination = getElementCombination(currentDraggedElement.dataset.label, el.dataset.label);
            if (combination) {
              // Play combination sound if enabled
              if (soundEnabled) {
                document.getElementById('combination-sound').play();
              }
              // Remove the collided elements
              document.body.removeChild(currentDraggedElement);
              document.body.removeChild(el);

              // Spawn new element from combination
              spawnNewElement(combination.emoji, combination.name, currentDraggedElement.style.left, currentDraggedElement.style.top);

              // Add new element to the sidebar
              addElementToSidebar(combination.emoji, combination.name);

              // Update counter after adding new element
              updateCounters();
            }
          }
        });
      }
      elementsToCheck = [];
    }
    currentDraggedElement = null;
  }

  function getElementCombination(type1, type2) {
    const combination1 = `${type1}+${type2}`;
    const combination2 = `${type2}+${type1}`; // Allow reverse combinations
    return lookupTable[combination1] || lookupTable[combination2] || null;
  }

  function isColliding(el1, el2) {
    const rect1 = el1.getBoundingClientRect();
    const rect2 = el2.getBoundingClientRect();

    return !(rect1.right < rect2.left || 
             rect1.left > rect2.right || 
             rect1.bottom < rect2.top || 
             rect1.top > rect2.bottom);
  }

  function spawnNewElement(emoji, name, x, y) {
    const newElement = document.createElement('div');
    newElement.classList.add('cloned');
    newElement.dataset.label = name;
    newElement.innerHTML = `${emoji} ${name}`;
    
    newElement.style.width = `${currentDraggedElement.offsetWidth}px`;
    newElement.style.height = `${currentDraggedElement.offsetHeight}px`;
    
    newElement.style.position = 'absolute';
    newElement.style.left = x; // Use the x and y values passed from the previous element
    newElement.style.top = y;

    newElement.addEventListener('mousedown', function(event) {
      currentDraggedElement = newElement;
      newElement.style.zIndex = '1001'; // Bring to front when dragging
      moveElement(event);
    });

    newElement.addEventListener('mouseup', function() {
      if (currentDraggedElement) {
        elementsToCheck.push(newElement);
        newElement.style.zIndex = '1000'; // Reset z-index after dragging
      }
    });

    document.addEventListener('mousemove', moveElement);
    document.addEventListener('mouseup', handleMouseUp);

    document.body.appendChild(newElement);
    updateCounters(); // Update counter when a new element is spawned
  }

  function addElementToSidebar(emoji, name) {
    // Check if the element already exists in the sidebar
    const existingElement = document.querySelector(`#sidebar .element[data-label="${name}"]`);
    if (!existingElement) {
      const newElement = document.createElement('div');
      newElement.classList.add('element');
      newElement.dataset.label = name;
      newElement.dataset.type = name; // Use the name for type
      newElement.innerHTML = `${emoji} ${name}`;

      newElement.addEventListener('click', function() {
        cloneElement(newElement);
      });

      document.getElementById('sidebar').appendChild(newElement);
      updateCounters(); // Update counter when a new element is added
    }
  }
</script>

</body>
</html>
